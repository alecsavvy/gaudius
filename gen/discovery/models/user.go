// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// User user
//
// swagger:model user
type User struct {

	// album count
	// Required: true
	AlbumCount *int64 `json:"album_count"`

	// artist pick track id
	ArtistPickTrackID string `json:"artist_pick_track_id,omitempty"`

	// bio
	Bio string `json:"bio,omitempty"`

	// cover photo
	CoverPhoto *CoverPhoto `json:"cover_photo,omitempty"`

	// does follow current user
	DoesFollowCurrentUser bool `json:"does_follow_current_user,omitempty"`

	// erc wallet
	// Required: true
	ErcWallet *string `json:"erc_wallet"`

	// followee count
	// Required: true
	FolloweeCount *int64 `json:"followee_count"`

	// follower count
	// Required: true
	FollowerCount *int64 `json:"follower_count"`

	// handle
	// Required: true
	Handle *string `json:"handle"`

	// id
	// Required: true
	ID *string `json:"id"`

	// is available
	// Required: true
	IsAvailable *bool `json:"is_available"`

	// is deactivated
	// Required: true
	IsDeactivated *bool `json:"is_deactivated"`

	// is verified
	// Required: true
	IsVerified *bool `json:"is_verified"`

	// location
	Location string `json:"location,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// playlist count
	// Required: true
	PlaylistCount *int64 `json:"playlist_count"`

	// profile picture
	ProfilePicture *ProfilePicture `json:"profile_picture,omitempty"`

	// repost count
	// Required: true
	RepostCount *int64 `json:"repost_count"`

	// spl wallet
	// Required: true
	SplWallet *string `json:"spl_wallet"`

	// supporter count
	// Required: true
	SupporterCount *int64 `json:"supporter_count"`

	// supporting count
	// Required: true
	SupportingCount *int64 `json:"supporting_count"`

	// total audio balance
	// Required: true
	TotalAudioBalance *int64 `json:"total_audio_balance"`

	// track count
	// Required: true
	TrackCount *int64 `json:"track_count"`
}

// Validate validates this user
func (m *User) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlbumCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoverPhoto(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErcWallet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFolloweeCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFollowerCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHandle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDeactivated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsVerified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlaylistCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfilePicture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepostCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSplWallet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupporterCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportingCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalAudioBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrackCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) validateAlbumCount(formats strfmt.Registry) error {

	if err := validate.Required("album_count", "body", m.AlbumCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateCoverPhoto(formats strfmt.Registry) error {
	if swag.IsZero(m.CoverPhoto) { // not required
		return nil
	}

	if m.CoverPhoto != nil {
		if err := m.CoverPhoto.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateErcWallet(formats strfmt.Registry) error {

	if err := validate.Required("erc_wallet", "body", m.ErcWallet); err != nil {
		return err
	}

	return nil
}

func (m *User) validateFolloweeCount(formats strfmt.Registry) error {

	if err := validate.Required("followee_count", "body", m.FolloweeCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateFollowerCount(formats strfmt.Registry) error {

	if err := validate.Required("follower_count", "body", m.FollowerCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateHandle(formats strfmt.Registry) error {

	if err := validate.Required("handle", "body", m.Handle); err != nil {
		return err
	}

	return nil
}

func (m *User) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *User) validateIsAvailable(formats strfmt.Registry) error {

	if err := validate.Required("is_available", "body", m.IsAvailable); err != nil {
		return err
	}

	return nil
}

func (m *User) validateIsDeactivated(formats strfmt.Registry) error {

	if err := validate.Required("is_deactivated", "body", m.IsDeactivated); err != nil {
		return err
	}

	return nil
}

func (m *User) validateIsVerified(formats strfmt.Registry) error {

	if err := validate.Required("is_verified", "body", m.IsVerified); err != nil {
		return err
	}

	return nil
}

func (m *User) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *User) validatePlaylistCount(formats strfmt.Registry) error {

	if err := validate.Required("playlist_count", "body", m.PlaylistCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateProfilePicture(formats strfmt.Registry) error {
	if swag.IsZero(m.ProfilePicture) { // not required
		return nil
	}

	if m.ProfilePicture != nil {
		if err := m.ProfilePicture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture")
			}
			return err
		}
	}

	return nil
}

func (m *User) validateRepostCount(formats strfmt.Registry) error {

	if err := validate.Required("repost_count", "body", m.RepostCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateSplWallet(formats strfmt.Registry) error {

	if err := validate.Required("spl_wallet", "body", m.SplWallet); err != nil {
		return err
	}

	return nil
}

func (m *User) validateSupporterCount(formats strfmt.Registry) error {

	if err := validate.Required("supporter_count", "body", m.SupporterCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateSupportingCount(formats strfmt.Registry) error {

	if err := validate.Required("supporting_count", "body", m.SupportingCount); err != nil {
		return err
	}

	return nil
}

func (m *User) validateTotalAudioBalance(formats strfmt.Registry) error {

	if err := validate.Required("total_audio_balance", "body", m.TotalAudioBalance); err != nil {
		return err
	}

	return nil
}

func (m *User) validateTrackCount(formats strfmt.Registry) error {

	if err := validate.Required("track_count", "body", m.TrackCount); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this user based on the context it is used
func (m *User) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCoverPhoto(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProfilePicture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *User) contextValidateCoverPhoto(ctx context.Context, formats strfmt.Registry) error {

	if m.CoverPhoto != nil {

		if swag.IsZero(m.CoverPhoto) { // not required
			return nil
		}

		if err := m.CoverPhoto.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo")
			}
			return err
		}
	}

	return nil
}

func (m *User) contextValidateProfilePicture(ctx context.Context, formats strfmt.Registry) error {

	if m.ProfilePicture != nil {

		if swag.IsZero(m.ProfilePicture) { // not required
			return nil
		}

		if err := m.ProfilePicture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *User) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *User) UnmarshalBinary(b []byte) error {
	var res User
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
