// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserFull user full
//
// swagger:model user_full
type UserFull struct {

	// album count
	// Required: true
	AlbumCount *int64 `json:"album_count"`

	// allow ai attribution
	// Required: true
	AllowAiAttribution *bool `json:"allow_ai_attribution"`

	// artist pick track id
	ArtistPickTrackID string `json:"artist_pick_track_id,omitempty"`

	// associated sol wallets balance
	// Required: true
	AssociatedSolWalletsBalance *string `json:"associated_sol_wallets_balance"`

	// associated wallets balance
	// Required: true
	AssociatedWalletsBalance *string `json:"associated_wallets_balance"`

	// balance
	// Required: true
	Balance *string `json:"balance"`

	// bio
	Bio string `json:"bio,omitempty"`

	// blocknumber
	// Required: true
	Blocknumber *int64 `json:"blocknumber"`

	// cover photo
	CoverPhoto *CoverPhoto `json:"cover_photo,omitempty"`

	// cover photo cids
	CoverPhotoCids *CoverPhoto `json:"cover_photo_cids,omitempty"`

	// cover photo legacy
	CoverPhotoLegacy string `json:"cover_photo_legacy,omitempty"`

	// cover photo sizes
	CoverPhotoSizes string `json:"cover_photo_sizes,omitempty"`

	// created at
	// Required: true
	CreatedAt *string `json:"created_at"`

	// creator node endpoint
	CreatorNodeEndpoint string `json:"creator_node_endpoint,omitempty"`

	// current user followee follow count
	// Required: true
	CurrentUserFolloweeFollowCount *int64 `json:"current_user_followee_follow_count"`

	// does current user follow
	// Required: true
	DoesCurrentUserFollow *bool `json:"does_current_user_follow"`

	// does current user subscribe
	// Required: true
	DoesCurrentUserSubscribe *bool `json:"does_current_user_subscribe"`

	// does follow current user
	DoesFollowCurrentUser bool `json:"does_follow_current_user,omitempty"`

	// erc wallet
	// Required: true
	ErcWallet *string `json:"erc_wallet"`

	// followee count
	// Required: true
	FolloweeCount *int64 `json:"followee_count"`

	// follower count
	// Required: true
	FollowerCount *int64 `json:"follower_count"`

	// handle
	// Required: true
	Handle *string `json:"handle"`

	// handle lc
	// Required: true
	HandleLc *string `json:"handle_lc"`

	// has collectibles
	// Required: true
	HasCollectibles *bool `json:"has_collectibles"`

	// id
	// Required: true
	ID *string `json:"id"`

	// is available
	// Required: true
	IsAvailable *bool `json:"is_available"`

	// is deactivated
	// Required: true
	IsDeactivated *bool `json:"is_deactivated"`

	// is storage v2
	// Required: true
	IsStorageV2 *bool `json:"is_storage_v2"`

	// is verified
	// Required: true
	IsVerified *bool `json:"is_verified"`

	// location
	Location string `json:"location,omitempty"`

	// metadata multihash
	MetadataMultihash string `json:"metadata_multihash,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// playlist count
	// Required: true
	PlaylistCount *int64 `json:"playlist_count"`

	// playlist library
	PlaylistLibrary *PlaylistLibrary `json:"playlist_library,omitempty"`

	// profile picture
	ProfilePicture *ProfilePicture `json:"profile_picture,omitempty"`

	// profile picture cids
	ProfilePictureCids *ProfilePicture `json:"profile_picture_cids,omitempty"`

	// profile picture legacy
	ProfilePictureLegacy string `json:"profile_picture_legacy,omitempty"`

	// profile picture sizes
	ProfilePictureSizes string `json:"profile_picture_sizes,omitempty"`

	// repost count
	// Required: true
	RepostCount *int64 `json:"repost_count"`

	// spl wallet
	// Required: true
	SplWallet *string `json:"spl_wallet"`

	// supporter count
	// Required: true
	SupporterCount *int64 `json:"supporter_count"`

	// supporting count
	// Required: true
	SupportingCount *int64 `json:"supporting_count"`

	// total audio balance
	// Required: true
	TotalAudioBalance *int64 `json:"total_audio_balance"`

	// total balance
	// Required: true
	TotalBalance *string `json:"total_balance"`

	// track count
	// Required: true
	TrackCount *int64 `json:"track_count"`

	// updated at
	// Required: true
	UpdatedAt *string `json:"updated_at"`

	// wallet
	// Required: true
	Wallet *string `json:"wallet"`

	// waudio balance
	// Required: true
	WaudioBalance *string `json:"waudio_balance"`
}

// Validate validates this user full
func (m *UserFull) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlbumCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowAiAttribution(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssociatedSolWalletsBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssociatedWalletsBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlocknumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoverPhoto(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCoverPhotoCids(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentUserFolloweeFollowCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDoesCurrentUserFollow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDoesCurrentUserSubscribe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErcWallet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFolloweeCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFollowerCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHandle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHandleLc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasCollectibles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsDeactivated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsStorageV2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsVerified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlaylistCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlaylistLibrary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfilePicture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProfilePictureCids(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepostCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSplWallet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupporterCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportingCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalAudioBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrackCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWallet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWaudioBalance(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserFull) validateAlbumCount(formats strfmt.Registry) error {

	if err := validate.Required("album_count", "body", m.AlbumCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateAllowAiAttribution(formats strfmt.Registry) error {

	if err := validate.Required("allow_ai_attribution", "body", m.AllowAiAttribution); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateAssociatedSolWalletsBalance(formats strfmt.Registry) error {

	if err := validate.Required("associated_sol_wallets_balance", "body", m.AssociatedSolWalletsBalance); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateAssociatedWalletsBalance(formats strfmt.Registry) error {

	if err := validate.Required("associated_wallets_balance", "body", m.AssociatedWalletsBalance); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateBalance(formats strfmt.Registry) error {

	if err := validate.Required("balance", "body", m.Balance); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateBlocknumber(formats strfmt.Registry) error {

	if err := validate.Required("blocknumber", "body", m.Blocknumber); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateCoverPhoto(formats strfmt.Registry) error {
	if swag.IsZero(m.CoverPhoto) { // not required
		return nil
	}

	if m.CoverPhoto != nil {
		if err := m.CoverPhoto.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) validateCoverPhotoCids(formats strfmt.Registry) error {
	if swag.IsZero(m.CoverPhotoCids) { // not required
		return nil
	}

	if m.CoverPhotoCids != nil {
		if err := m.CoverPhotoCids.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo_cids")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo_cids")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) validateCreatedAt(formats strfmt.Registry) error {

	if err := validate.Required("created_at", "body", m.CreatedAt); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateCurrentUserFolloweeFollowCount(formats strfmt.Registry) error {

	if err := validate.Required("current_user_followee_follow_count", "body", m.CurrentUserFolloweeFollowCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateDoesCurrentUserFollow(formats strfmt.Registry) error {

	if err := validate.Required("does_current_user_follow", "body", m.DoesCurrentUserFollow); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateDoesCurrentUserSubscribe(formats strfmt.Registry) error {

	if err := validate.Required("does_current_user_subscribe", "body", m.DoesCurrentUserSubscribe); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateErcWallet(formats strfmt.Registry) error {

	if err := validate.Required("erc_wallet", "body", m.ErcWallet); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateFolloweeCount(formats strfmt.Registry) error {

	if err := validate.Required("followee_count", "body", m.FolloweeCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateFollowerCount(formats strfmt.Registry) error {

	if err := validate.Required("follower_count", "body", m.FollowerCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateHandle(formats strfmt.Registry) error {

	if err := validate.Required("handle", "body", m.Handle); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateHandleLc(formats strfmt.Registry) error {

	if err := validate.Required("handle_lc", "body", m.HandleLc); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateHasCollectibles(formats strfmt.Registry) error {

	if err := validate.Required("has_collectibles", "body", m.HasCollectibles); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateIsAvailable(formats strfmt.Registry) error {

	if err := validate.Required("is_available", "body", m.IsAvailable); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateIsDeactivated(formats strfmt.Registry) error {

	if err := validate.Required("is_deactivated", "body", m.IsDeactivated); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateIsStorageV2(formats strfmt.Registry) error {

	if err := validate.Required("is_storage_v2", "body", m.IsStorageV2); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateIsVerified(formats strfmt.Registry) error {

	if err := validate.Required("is_verified", "body", m.IsVerified); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validatePlaylistCount(formats strfmt.Registry) error {

	if err := validate.Required("playlist_count", "body", m.PlaylistCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validatePlaylistLibrary(formats strfmt.Registry) error {
	if swag.IsZero(m.PlaylistLibrary) { // not required
		return nil
	}

	if m.PlaylistLibrary != nil {
		if err := m.PlaylistLibrary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playlist_library")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("playlist_library")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) validateProfilePicture(formats strfmt.Registry) error {
	if swag.IsZero(m.ProfilePicture) { // not required
		return nil
	}

	if m.ProfilePicture != nil {
		if err := m.ProfilePicture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) validateProfilePictureCids(formats strfmt.Registry) error {
	if swag.IsZero(m.ProfilePictureCids) { // not required
		return nil
	}

	if m.ProfilePictureCids != nil {
		if err := m.ProfilePictureCids.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture_cids")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture_cids")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) validateRepostCount(formats strfmt.Registry) error {

	if err := validate.Required("repost_count", "body", m.RepostCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateSplWallet(formats strfmt.Registry) error {

	if err := validate.Required("spl_wallet", "body", m.SplWallet); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateSupporterCount(formats strfmt.Registry) error {

	if err := validate.Required("supporter_count", "body", m.SupporterCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateSupportingCount(formats strfmt.Registry) error {

	if err := validate.Required("supporting_count", "body", m.SupportingCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateTotalAudioBalance(formats strfmt.Registry) error {

	if err := validate.Required("total_audio_balance", "body", m.TotalAudioBalance); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateTotalBalance(formats strfmt.Registry) error {

	if err := validate.Required("total_balance", "body", m.TotalBalance); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateTrackCount(formats strfmt.Registry) error {

	if err := validate.Required("track_count", "body", m.TrackCount); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("updated_at", "body", m.UpdatedAt); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateWallet(formats strfmt.Registry) error {

	if err := validate.Required("wallet", "body", m.Wallet); err != nil {
		return err
	}

	return nil
}

func (m *UserFull) validateWaudioBalance(formats strfmt.Registry) error {

	if err := validate.Required("waudio_balance", "body", m.WaudioBalance); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this user full based on the context it is used
func (m *UserFull) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCoverPhoto(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCoverPhotoCids(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlaylistLibrary(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProfilePicture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProfilePictureCids(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserFull) contextValidateCoverPhoto(ctx context.Context, formats strfmt.Registry) error {

	if m.CoverPhoto != nil {

		if swag.IsZero(m.CoverPhoto) { // not required
			return nil
		}

		if err := m.CoverPhoto.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) contextValidateCoverPhotoCids(ctx context.Context, formats strfmt.Registry) error {

	if m.CoverPhotoCids != nil {

		if swag.IsZero(m.CoverPhotoCids) { // not required
			return nil
		}

		if err := m.CoverPhotoCids.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cover_photo_cids")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cover_photo_cids")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) contextValidatePlaylistLibrary(ctx context.Context, formats strfmt.Registry) error {

	if m.PlaylistLibrary != nil {

		if swag.IsZero(m.PlaylistLibrary) { // not required
			return nil
		}

		if err := m.PlaylistLibrary.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("playlist_library")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("playlist_library")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) contextValidateProfilePicture(ctx context.Context, formats strfmt.Registry) error {

	if m.ProfilePicture != nil {

		if swag.IsZero(m.ProfilePicture) { // not required
			return nil
		}

		if err := m.ProfilePicture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture")
			}
			return err
		}
	}

	return nil
}

func (m *UserFull) contextValidateProfilePictureCids(ctx context.Context, formats strfmt.Registry) error {

	if m.ProfilePictureCids != nil {

		if swag.IsZero(m.ProfilePictureCids) { // not required
			return nil
		}

		if err := m.ProfilePictureCids.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile_picture_cids")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("profile_picture_cids")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserFull) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserFull) UnmarshalBinary(b []byte) error {
	var res UserFull
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
