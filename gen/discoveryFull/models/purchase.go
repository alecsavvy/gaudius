// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// Purchase purchase
//
// swagger:discriminator purchase content_type
type Purchase interface {
	runtime.Validatable
	runtime.ContextValidatable

	// amount
	// Required: true
	Amount() *string
	SetAmount(*string)

	// buyer user id
	// Required: true
	BuyerUserID() *string
	SetBuyerUserID(*string)

	// content id
	// Required: true
	ContentID() *string
	SetContentID(*string)

	// content type
	// Required: true
	ContentType() string
	SetContentType(string)

	// created at
	// Required: true
	CreatedAt() *string
	SetCreatedAt(*string)

	// extra amount
	// Required: true
	ExtraAmount() *string
	SetExtraAmount(*string)

	// seller user id
	// Required: true
	SellerUserID() *string
	SetSellerUserID(*string)

	// signature
	// Required: true
	Signature() *string
	SetSignature(*string)

	// slot
	// Required: true
	Slot() *int64
	SetSlot(*int64)

	// updated at
	// Required: true
	UpdatedAt() *string
	SetUpdatedAt(*string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type purchase struct {
	amountField *string

	buyerUserIdField *string

	contentIdField *string

	contentTypeField string

	createdAtField *string

	extraAmountField *string

	sellerUserIdField *string

	signatureField *string

	slotField *int64

	updatedAtField *string
}

// Amount gets the amount of this polymorphic type
func (m *purchase) Amount() *string {
	return m.amountField
}

// SetAmount sets the amount of this polymorphic type
func (m *purchase) SetAmount(val *string) {
	m.amountField = val
}

// BuyerUserID gets the buyer user id of this polymorphic type
func (m *purchase) BuyerUserID() *string {
	return m.buyerUserIdField
}

// SetBuyerUserID sets the buyer user id of this polymorphic type
func (m *purchase) SetBuyerUserID(val *string) {
	m.buyerUserIdField = val
}

// ContentID gets the content id of this polymorphic type
func (m *purchase) ContentID() *string {
	return m.contentIdField
}

// SetContentID sets the content id of this polymorphic type
func (m *purchase) SetContentID(val *string) {
	m.contentIdField = val
}

// ContentType gets the content type of this polymorphic type
func (m *purchase) ContentType() string {
	return "purchase"
}

// SetContentType sets the content type of this polymorphic type
func (m *purchase) SetContentType(val string) {
}

// CreatedAt gets the created at of this polymorphic type
func (m *purchase) CreatedAt() *string {
	return m.createdAtField
}

// SetCreatedAt sets the created at of this polymorphic type
func (m *purchase) SetCreatedAt(val *string) {
	m.createdAtField = val
}

// ExtraAmount gets the extra amount of this polymorphic type
func (m *purchase) ExtraAmount() *string {
	return m.extraAmountField
}

// SetExtraAmount sets the extra amount of this polymorphic type
func (m *purchase) SetExtraAmount(val *string) {
	m.extraAmountField = val
}

// SellerUserID gets the seller user id of this polymorphic type
func (m *purchase) SellerUserID() *string {
	return m.sellerUserIdField
}

// SetSellerUserID sets the seller user id of this polymorphic type
func (m *purchase) SetSellerUserID(val *string) {
	m.sellerUserIdField = val
}

// Signature gets the signature of this polymorphic type
func (m *purchase) Signature() *string {
	return m.signatureField
}

// SetSignature sets the signature of this polymorphic type
func (m *purchase) SetSignature(val *string) {
	m.signatureField = val
}

// Slot gets the slot of this polymorphic type
func (m *purchase) Slot() *int64 {
	return m.slotField
}

// SetSlot sets the slot of this polymorphic type
func (m *purchase) SetSlot(val *int64) {
	m.slotField = val
}

// UpdatedAt gets the updated at of this polymorphic type
func (m *purchase) UpdatedAt() *string {
	return m.updatedAtField
}

// SetUpdatedAt sets the updated at of this polymorphic type
func (m *purchase) SetUpdatedAt(val *string) {
	m.updatedAtField = val
}

// UnmarshalPurchaseSlice unmarshals polymorphic slices of Purchase
func UnmarshalPurchaseSlice(reader io.Reader, consumer runtime.Consumer) ([]Purchase, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []Purchase
	for _, element := range elements {
		obj, err := unmarshalPurchase(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalPurchase unmarshals polymorphic Purchase
func UnmarshalPurchase(reader io.Reader, consumer runtime.Consumer) (Purchase, error) {
	// we need to read this twice, so first into a buffer
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalPurchase(data, consumer)
}

func unmarshalPurchase(data []byte, consumer runtime.Consumer) (Purchase, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the content_type property.
	var getType struct {
		ContentType string `json:"content_type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("content_type", "body", getType.ContentType); err != nil {
		return nil, err
	}

	// The value of content_type is used to determine which type to create and unmarshal the data into
	switch getType.ContentType {
	case "purchase":
		var result purchase
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid content_type value: %q", getType.ContentType)
}

// Validate validates this purchase
func (m *purchase) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuyerUserID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtraAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellerUserID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignature(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSlot(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *purchase) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("amount", "body", m.Amount()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateBuyerUserID(formats strfmt.Registry) error {

	if err := validate.Required("buyer_user_id", "body", m.BuyerUserID()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateContentID(formats strfmt.Registry) error {

	if err := validate.Required("content_id", "body", m.ContentID()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateCreatedAt(formats strfmt.Registry) error {

	if err := validate.Required("created_at", "body", m.CreatedAt()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateExtraAmount(formats strfmt.Registry) error {

	if err := validate.Required("extra_amount", "body", m.ExtraAmount()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateSellerUserID(formats strfmt.Registry) error {

	if err := validate.Required("seller_user_id", "body", m.SellerUserID()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateSignature(formats strfmt.Registry) error {

	if err := validate.Required("signature", "body", m.Signature()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateSlot(formats strfmt.Registry) error {

	if err := validate.Required("slot", "body", m.Slot()); err != nil {
		return err
	}

	return nil
}

func (m *purchase) validateUpdatedAt(formats strfmt.Registry) error {

	if err := validate.Required("updated_at", "body", m.UpdatedAt()); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this purchase based on context it is used
func (m *purchase) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}
